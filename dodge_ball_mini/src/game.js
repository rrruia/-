const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let scale = 1;
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; scale = Math.min(canvas.width / 375, canvas.height / 667) }
resize();
window.addEventListener("resize", resize);
class Player { constructor(x, y, w, h, s, c) { this.cx = x; this.cy = y; this.w = w; this.h = h; this.s = s; this.c = c } left() { this.cx -= this.s } right() { this.cx += this.s } update(dt) { if (keys.left) this.cx -= this.s * dt; if (keys.right) this.cx += this.s * dt; this.cx = Math.max(this.w / 2, Math.min(canvas.width - this.w / 2, this.cx)) } draw() { ctx.fillStyle = this.c; ctx.fillRect(this.cx - this.w / 2, this.cy - this.h / 2, this.w, this.h) } }
class EnemyBall { constructor(x, y, r, s, c, t = "straight", vx = 0, a = 0) { this.x = x; this.y = y; this.r = r; this.s = s; this.c = c; this.t = t; this.vx = vx; this.a = a; this.alive = true } update(dt) { if (this.t === "accelerate") { this.s += this.a * dt } this.y += this.s * dt; if (this.t === "bounce") { this.x += this.vx * dt; if (this.x - this.r < 0) { this.x = this.r; this.vx = -this.vx } if (this.x + this.r > canvas.width) { this.x = canvas.width - this.r; this.vx = -this.vx } } if (this.y - this.r > canvas.height) this.alive = false } draw() { ctx.fillStyle = this.c; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2); ctx.fill() } }
function collideCircleRect(cx, cy, r, rx, ry, rw, rh) { const x = Math.max(rx, Math.min(cx, rx + rw)); const y = Math.max(ry, Math.min(cy, ry + rh)); const dx = cx - x; const dy = cy - y; return dx * dx + dy * dy <= r * r }
const keys = { left: false, right: false };
const uiScore = document.getElementById("score");
const pauseBtn = document.getElementById("pauseBtn");
const overlay = document.getElementById("overlay");
const pauseOverlay = document.getElementById("pauseOverlay");
const centerPauseBtn = document.getElementById("centerPauseBtn");
const helpBtn = document.getElementById("helpBtn");
const helpOverlay = document.getElementById("helpOverlay");
const helpCloseBtn = document.getElementById("helpCloseBtn");
const soundBtn = document.getElementById("soundBtn");
const soundState = document.getElementById("soundState");
const startOverlay = document.getElementById("startOverlay");
const startBtn = document.getElementById("startBtn");
function updateSoundUI() { let el = document.getElementById("soundState"); if (!el) { soundBtn.innerHTML = "<span id=\"soundState\"></span><span class=\"hint\">Q</span>"; el = document.getElementById("soundState"); } el.textContent = audio.muted ? "静音" : "开声音" }
const pauseScore = document.getElementById("pauseScore");
const finalScore = document.getElementById("finalScore");
const restartBtn = document.getElementById("restartBtn");
let hasStarted = false;
let pauseEnableAt = 0;
function startGame() { audio.init(); if (!hasStarted) { hasStarted = true; if (startOverlay) startOverlay.remove(); game.paused = false; pauseBtn.textContent = "暂停"; audio.allowAutoPlay = true; audio.playBGM() } }
class AudioManager { constructor() { this.ctx = null; this.master = null; this.bgmOsc = null; this.bgmOsc2 = null; this.bgmTimer = null; this.audioEl = null; this.started = false; this.masterVolume = 0.25; this.muted = false } init() { if (!this.audioEl) { try { const src = "Sound Souler - Pure Powder.mp3"; this.audioEl = new Audio(src); this.audioEl.loop = false; this.audioEl.preload = "auto"; this.audioEl.crossOrigin = "anonymous"; this.audioEl.playsInline = true; this.audioEl.volume = 0.4; this.audioEl.addEventListener("loadedmetadata", () => { try { const d = this.audioEl.duration || 0; this.audioEl.currentTime = Math.min(1, d > 1 ? 1 : 0) } catch (e) { } }); this.audioEl.addEventListener("ended", () => { try { this.audioEl.currentTime = 1; if (!this.muted) this.audioEl.play().catch(() => { }) } catch (e) { } }) } catch (e) { } } if (this.audioEl) { this.audioEl.muted = this.muted; if (!this.started) this.playBGM() } if (!this.ctx) { try { this.ctx = new (window.AudioContext || window.webkitAudioContext)() } catch (e) { } if (this.ctx) { this.master = this.ctx.createGain(); this.master.gain.value = this.masterVolume; this.master.connect(this.ctx.destination) } } if (this.ctx) this.ctx.resume() } setMute(m) { this.muted = !!m; if (this.audioEl) this.audioEl.muted = this.muted } playBGM() { if (!this.audioEl) return; this.audioEl.muted = this.muted; try { if (this.audioEl.currentTime < 1) this.audioEl.currentTime = 1 } catch (e) { } this.audioEl.play().catch(() => { }); this.started = true } pauseBGM() { if (this.audioEl) { try { this.audioEl.pause() } catch (e) { } } } resumeBGM() { if (this.audioEl) { try { if (this.audioEl.currentTime < 1) this.audioEl.currentTime = 1 } catch (e) { } if (!this.muted) this.audioEl.play().catch(() => { }); return } } stopBGM() { if (this.audioEl) { try { this.audioEl.pause() } catch (e) { } try { this.audioEl.currentTime = 0 } catch (e) { } this.started = false } if (this.bgmTimer) { clearInterval(this.bgmTimer); this.bgmTimer = null } if (this.bgmOsc) { try { this.bgmOsc.stop() } catch (e) { } this.bgmOsc = null } if (this.bgmOsc2) { try { this.bgmOsc2.stop() } catch (e) { } this.bgmOsc2 = null } } playEnd() { if (!this.ctx) return; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.type = "square"; o.frequency.setValueAtTime(600, this.ctx.currentTime); g.gain.setValueAtTime(0.28, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + 0.35); o.connect(g); g.connect(this.master); o.start(); o.frequency.exponentialRampToValueAtTime(150, this.ctx.currentTime + 0.35); o.stop(this.ctx.currentTime + 0.36) } playRestart() { if (!this.ctx) return; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.type = "sine"; o.frequency.setValueAtTime(280, this.ctx.currentTime); g.gain.setValueAtTime(0.28, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + 0.2); o.connect(g); g.connect(this.master); o.start(); o.frequency.exponentialRampToValueAtTime(520, this.ctx.currentTime + 0.2); o.stop(this.ctx.currentTime + 0.21) } }
const audio = new AudioManager();
audio.allowAutoPlay = false;
(function () { const __origPlayBGM = AudioManager.prototype.playBGM; AudioManager.prototype.playBGM = function () { if (!this.allowAutoPlay) return; return __origPlayBGM.call(this) } })();
AudioManager.prototype.playPause = function () { if (!this.ctx) return; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.type = "triangle"; o.frequency.setValueAtTime(420, this.ctx.currentTime); g.gain.setValueAtTime(0.5, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + 0.18); o.connect(g); g.connect(this.master); o.start(); o.stop(this.ctx.currentTime + 0.19) };
AudioManager.prototype.playRestartLoud = function () { if (!this.ctx) return; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.type = "sine"; o.frequency.setValueAtTime(280, this.ctx.currentTime); g.gain.setValueAtTime(0.5, this.ctx.currentTime); g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + 0.25); o.connect(g); g.connect(this.master); o.start(); o.frequency.exponentialRampToValueAtTime(520, this.ctx.currentTime + 0.25); o.stop(this.ctx.currentTime + 0.26) };
// removed procedural BGM; MP3 is used exclusively
class Game { constructor() { this.reset() } reset() { this.player = new Player(canvas.width / 2, canvas.height - 24 * scale, 60 * scale, 14 * scale, 360 * scale, "#f0f0f0"); this.enemies = []; this.last = performance.now(); this.acc = 0; this.score = 0; this.gameOver = false; this.paused = false; this.spawnInterval = 900; this.lastSpawn = 0; this.difficultyTimer = 0; this.speedBase = 280 * scale; overlay.classList.add("hidden"); uiScore.textContent = "Score: 0.0s" } spawn() { const hard = Math.min(1, this.score / 60); let group = 1; if (hard > 0.3 && Math.random() < 0.6) group = 2; if (hard > 0.7 && Math.random() < 0.5) group = 3; const xs = []; for (let j = 0; j < group; j++) { const rBase = 10 * scale; const r = rBase + Math.random() * 16 * scale; let x; let tries = 0; do { x = r + Math.random() * (canvas.width - 2 * r); tries++; } while (xs.some(px => Math.abs(px - x) < r * 2.2) && tries < 8); xs.push(x); const tRand = Math.random(); let t = "straight"; if (tRand < 0.15 + 0.35 * hard) t = "bounce"; else if (tRand < 0.35 + 0.35 * hard) t = "accelerate"; const s = this.speedBase * (1.05 + Math.random() * 0.85); if (t === "bounce") { const vx = (60 * scale + Math.random() * 120 * scale) * (Math.random() < 0.5 ? -1 : 1); this.enemies.push(new EnemyBall(x, -r, r, s, "#ff8e5d", t, vx, 0)) } else if (t === "accelerate") { const a = 70 * scale + Math.random() * 120 * scale; this.enemies.push(new EnemyBall(x, -r, Math.max(rBase, r - 2 * scale), s, "#ff5d9e", t, 0, a)) } else { this.enemies.push(new EnemyBall(x, -r, r, s, "#ff5d5d", t, 0, 0)) } } } update(dt) { if (this.paused || this.gameOver) return; this.acc += dt * 1000; this.difficultyTimer += dt; this.score += dt; this.player.update(dt); if (this.acc - this.lastSpawn >= this.spawnInterval) { this.spawn(); this.lastSpawn = this.acc } for (let i = 0; i < this.enemies.length; i++) { this.enemies[i].update(dt) } this.enemies = this.enemies.filter(e => e.alive); const rx = this.player.cx - this.player.w / 2; const ry = this.player.cy - this.player.h / 2; for (let i = 0; i < this.enemies.length; i++) { if (collideCircleRect(this.enemies[i].x, this.enemies[i].y, this.enemies[i].r, rx, ry, this.player.w, this.player.h)) { this.end(); break } } if (this.difficultyTimer >= 8) { this.difficultyTimer = 0; this.spawnInterval = Math.max(150, Math.floor(this.spawnInterval * 0.88)); this.speedBase *= 1.15 } uiScore.textContent = "Score: " + this.score.toFixed(1) + "s" } draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); this.player.draw(); for (let i = 0; i < this.enemies.length; i++) { this.enemies[i].draw() } } end() { this.gameOver = true; finalScore.textContent = "Score: " + this.score.toFixed(1) + "s"; overlay.classList.remove("hidden") } }
const game = new Game();
const __origEnd = Game.prototype.end; Game.prototype.end = function () { __origEnd.call(this); if (typeof audio !== "undefined") { audio.playEnd(); audio.stopBGM() } };
let prev = performance.now();
function loop(ts) { const dt = Math.min(0.033, (ts - prev) / 1000); prev = ts; game.update(dt); game.draw(); requestAnimationFrame(loop) }
requestAnimationFrame(loop);
game.paused = true;

game.paused = true;
document.addEventListener("keydown", e => { audio.init(); const k = e.key.toLowerCase(); if (!hasStarted && e.code === "Space") { e.preventDefault(); hasStarted = true; if (startOverlay) startOverlay.remove(); game.paused = false; pauseBtn.textContent = "暂停"; audio.playBGM(); return } if (e.key === "ArrowLeft" || k === "a") keys.left = true; if (e.key === "ArrowRight" || k === "d") keys.right = true; if (!e.repeat) { if (e.key === "Escape" && helpOverlay.classList.contains("hidden")) { e.preventDefault(); if (performance.now() < pauseEnableAt) return; if (!game.gameOver) { game.paused = !game.paused; pauseBtn.textContent = game.paused ? "继续" : "暂停"; if (game.paused) { pauseOverlay.classList.remove("hidden"); pauseScore.textContent = "Score: " + game.score.toFixed(1) + "s"; centerPauseBtn.textContent = "继续"; audio.playPause(); audio.pauseBGM() } else { pauseOverlay.classList.add("hidden"); centerPauseBtn.textContent = "暂停"; audio.resumeBGM() } } } else if (k === "e") { e.preventDefault(); if (performance.now() < pauseEnableAt) return; if (helpOverlay.classList.contains("hidden")) { if (game.gameOver) return; pausedBeforeHelp = game.paused; game.paused = true; pauseBtn.textContent = "继续"; pauseOverlay.classList.add("hidden"); helpOverlay.classList.remove("hidden"); audio.playPause(); audio.pauseBGM() } else { helpOverlay.classList.add("hidden"); if (!pausedBeforeHelp && !game.gameOver) { game.paused = false; pauseBtn.textContent = "暂停"; audio.resumeBGM() } else { game.paused = true; pauseBtn.textContent = "继续"; pauseOverlay.classList.remove("hidden") } } } else if (k === "q") { e.preventDefault(); audio.setMute(!audio.muted); soundBtn.textContent = audio.muted ? "开声音" : "静音" } else if (e.code === "Space") { e.preventDefault(); if (game.gameOver) { audio.playRestartLoud(); game.reset(); pauseBtn.textContent = "暂停"; pauseOverlay.classList.add("hidden"); audio.playBGM() } else if (helpOverlay.classList.contains("hidden")) { if (performance.now() < pauseEnableAt) return; if (!game.gameOver) { game.paused = !game.paused; pauseBtn.textContent = game.paused ? "继续" : "暂停"; if (game.paused) { pauseOverlay.classList.remove("hidden"); pauseScore.textContent = "Score: " + game.score.toFixed(1) + "s"; centerPauseBtn.textContent = "继续"; audio.playPause(); audio.pauseBGM() } else { pauseOverlay.classList.add("hidden"); centerPauseBtn.textContent = "暂停"; audio.resumeBGM() } } } else { helpOverlay.classList.add("hidden"); if (!pausedBeforeHelp && !game.gameOver) { game.paused = false; pauseBtn.textContent = "暂停"; audio.resumeBGM() } else { game.paused = true; pauseBtn.textContent = "继续"; pauseOverlay.classList.remove("hidden") } } } } });
document.addEventListener("keyup", e => { if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") keys.left = false; if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") keys.right = false });
let touchActive = false;
let pausedBeforeHelp = false;
function setPlayerX(x) { game.player.cx = Math.max(game.player.w / 2, Math.min(canvas.width - game.player.w / 2, x)) }
canvas.addEventListener("pointerdown", e => { audio.init(); if (e.pointerType !== "touch") return; touchActive = true; e.preventDefault() });
canvas.addEventListener("pointermove", e => { if (e.pointerType !== "touch" || !touchActive) return; const r = canvas.getBoundingClientRect(); setPlayerX(e.clientX - r.left); e.preventDefault() });
canvas.addEventListener("pointerup", e => { if (e.pointerType !== "touch") return; touchActive = false });
canvas.addEventListener("pointercancel", e => { if (e.pointerType !== "touch") return; touchActive = false });
pauseBtn.addEventListener("click", () => { audio.init(); if (game.gameOver) return; if (performance.now() < pauseEnableAt) return; game.paused = !game.paused; pauseBtn.textContent = game.paused ? "继续" : "暂停"; if (game.paused) { pauseOverlay.classList.remove("hidden"); pauseScore.textContent = "Score: " + game.score.toFixed(1) + "s"; centerPauseBtn.textContent = "继续"; audio.playPause(); audio.pauseBGM() } else { pauseOverlay.classList.add("hidden"); centerPauseBtn.textContent = "暂停"; audio.resumeBGM() } });
restartBtn.addEventListener("click", () => { audio.init(); audio.playRestartLoud(); game.reset(); pauseBtn.textContent = "暂停"; pauseOverlay.classList.add("hidden"); audio.playBGM() });
centerPauseBtn.addEventListener("click", () => { if (game.gameOver) return; game.paused = !game.paused; pauseBtn.textContent = game.paused ? "继续" : "暂停"; if (game.paused) { pauseOverlay.classList.remove("hidden"); pauseScore.textContent = "Score: " + game.score.toFixed(1) + "s"; centerPauseBtn.textContent = "继续"; audio.pauseBGM() } else { pauseOverlay.classList.add("hidden"); centerPauseBtn.textContent = "暂停"; audio.resumeBGM() } });
helpBtn.addEventListener("click", () => { audio.init(); if (game.gameOver) return; if (performance.now() < pauseEnableAt) return; pausedBeforeHelp = game.paused; game.paused = true; pauseBtn.textContent = "继续"; pauseOverlay.classList.add("hidden"); helpOverlay.classList.remove("hidden"); audio.playPause(); audio.pauseBGM() });
helpCloseBtn.addEventListener("click", () => { helpOverlay.classList.add("hidden"); if (!pausedBeforeHelp && !game.gameOver) { game.paused = false; pauseBtn.textContent = "暂停"; audio.resumeBGM() } else { game.paused = true; pauseBtn.textContent = "继续"; pauseOverlay.classList.remove("hidden") } });
if ("ontouchstart" in window) {
    canvas.addEventListener("touchstart", e => { audio.init(); const t = e.touches[0]; if (!t) return; touchActive = true; e.preventDefault() }, { passive: false });
    canvas.addEventListener("touchmove", e => { const t = e.touches[0]; if (!t || !touchActive) return; const r = canvas.getBoundingClientRect(); setPlayerX(t.clientX - r.left); e.preventDefault() }, { passive: false });
    canvas.addEventListener("touchend", () => { touchActive = false }, { passive: true });
}
startBtn.addEventListener("click", () => { pauseEnableAt = performance.now() + 20; startGame() });

soundBtn.addEventListener("click", () => { audio.init(); audio.setMute(!audio.muted) });
document.addEventListener("keydown", function (e) { if (!e.repeat && e.key.toLowerCase() === "q") { e.preventDefault(); e.stopImmediatePropagation(); audio.init(); audio.setMute(!audio.muted) } }, true);
