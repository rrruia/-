const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let scale = 1;
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; scale = Math.min(canvas.width / 375, canvas.height / 667) }
resize();
window.addEventListener("resize", resize);
class Player { constructor(x, y, w, h, s, c) { this.cx = x; this.cy = y; this.w = w; this.h = h; this.s = s; this.c = c } left() { this.cx -= this.s } right() { this.cx += this.s } update(dt) { if (keys.left) this.cx -= this.s * dt; if (keys.right) this.cx += this.s * dt; this.cx = Math.max(this.w / 2, Math.min(canvas.width - this.w / 2, this.cx)) } draw() { ctx.fillStyle = this.c; ctx.fillRect(this.cx - this.w / 2, this.cy - this.h / 2, this.w, this.h) } }
class EnemyBall { constructor(x, y, r, s, c, t = "straight", vx = 0, a = 0) { this.x = x; this.y = y; this.r = r; this.s = s; this.c = c; this.t = t; this.vx = vx; this.a = a; this.alive = true } update(dt) { if (this.t === "accelerate") { this.s += this.a * dt } this.y += this.s * dt; if (this.t === "bounce") { this.x += this.vx * dt; if (this.x - this.r < 0) { this.x = this.r; this.vx = -this.vx } if (this.x + this.r > canvas.width) { this.x = canvas.width - this.r; this.vx = -this.vx } } if (this.y - this.r > canvas.height) this.alive = false } draw() { ctx.fillStyle = this.c; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2); ctx.fill() } }
function collideCircleRect(cx, cy, r, rx, ry, rw, rh) { const x = Math.max(rx, Math.min(cx, rx + rw)); const y = Math.max(ry, Math.min(cy, ry + rh)); const dx = cx - x; const dy = cy - y; return dx * dx + dy * dy <= r * r }
const keys = { left: false, right: false };
const uiScore = document.getElementById("score");
const pauseBtn = document.getElementById("pauseBtn");
const overlay = document.getElementById("overlay");
const pauseOverlay = document.getElementById("pauseOverlay");
const centerPauseBtn = document.getElementById("centerPauseBtn");
const helpBtn = document.getElementById("helpBtn");
const helpOverlay = document.getElementById("helpOverlay");
const helpCloseBtn = document.getElementById("helpCloseBtn");
const pauseScore = document.getElementById("pauseScore");
const finalScore = document.getElementById("finalScore");
const restartBtn = document.getElementById("restartBtn");
class Game { constructor() { this.reset() } reset() { this.player = new Player(canvas.width / 2, canvas.height - 24 * scale, 60 * scale, 14 * scale, 360 * scale, "#f0f0f0"); this.enemies = []; this.last = performance.now(); this.acc = 0; this.score = 0; this.gameOver = false; this.paused = false; this.spawnInterval = 900; this.lastSpawn = 0; this.difficultyTimer = 0; this.speedBase = 280 * scale; overlay.classList.add("hidden"); uiScore.textContent = "Score: 0.0s" } spawn() { const hard = Math.min(1, this.score / 60); let group = 1; if (hard > 0.3 && Math.random() < 0.6) group = 2; if (hard > 0.7 && Math.random() < 0.5) group = 3; const xs = []; for (let j = 0; j < group; j++) { const rBase = 10 * scale; const r = rBase + Math.random() * 16 * scale; let x; let tries = 0; do { x = r + Math.random() * (canvas.width - 2 * r); tries++; } while (xs.some(px => Math.abs(px - x) < r * 2.2) && tries < 8); xs.push(x); const tRand = Math.random(); let t = "straight"; if (tRand < 0.15 + 0.35 * hard) t = "bounce"; else if (tRand < 0.35 + 0.35 * hard) t = "accelerate"; const s = this.speedBase * (1.05 + Math.random() * 0.85); if (t === "bounce") { const vx = (60 * scale + Math.random() * 120 * scale) * (Math.random() < 0.5 ? -1 : 1); this.enemies.push(new EnemyBall(x, -r, r, s, "#ff8e5d", t, vx, 0)) } else if (t === "accelerate") { const a = 70 * scale + Math.random() * 120 * scale; this.enemies.push(new EnemyBall(x, -r, Math.max(rBase, r - 2 * scale), s, "#ff5d9e", t, 0, a)) } else { this.enemies.push(new EnemyBall(x, -r, r, s, "#ff5d5d", t, 0, 0)) } } } update(dt) { if (this.paused || this.gameOver) return; this.acc += dt * 1000; this.difficultyTimer += dt; this.score += dt; this.player.update(dt); if (this.acc - this.lastSpawn >= this.spawnInterval) { this.spawn(); this.lastSpawn = this.acc } for (let i = 0; i < this.enemies.length; i++) { this.enemies[i].update(dt) } this.enemies = this.enemies.filter(e => e.alive); const rx = this.player.cx - this.player.w / 2; const ry = this.player.cy - this.player.h / 2; for (let i = 0; i < this.enemies.length; i++) { if (collideCircleRect(this.enemies[i].x, this.enemies[i].y, this.enemies[i].r, rx, ry, this.player.w, this.player.h)) { this.end(); break } } if (this.difficultyTimer >= 8) { this.difficultyTimer = 0; this.spawnInterval = Math.max(150, Math.floor(this.spawnInterval * 0.88)); this.speedBase *= 1.15 } uiScore.textContent = "Score: " + this.score.toFixed(1) + "s" } draw() { ctx.clearRect(0, 0, canvas.width, canvas.height); this.player.draw(); for (let i = 0; i < this.enemies.length; i++) { this.enemies[i].draw() } } end() { this.gameOver = true; finalScore.textContent = "Score: " + this.score.toFixed(1) + "s"; overlay.classList.remove("hidden") } }
const game = new Game();
let prev = performance.now();
function loop(ts) { const dt = Math.min(0.033, (ts - prev) / 1000); prev = ts; game.update(dt); game.draw(); requestAnimationFrame(loop) }
requestAnimationFrame(loop);
document.addEventListener("keydown", e => { if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") keys.left = true; if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") keys.right = true; if ((e.key === "Escape" || e.code === "Space" || e.key === " ") && !e.repeat && helpOverlay.classList.contains("hidden")) { e.preventDefault(); if (!game.gameOver) { game.paused = !game.paused; pauseBtn.textContent = game.paused ? "继续" : "暂停"; if (game.paused) { pauseOverlay.classList.remove("hidden"); pauseScore.textContent = "Score: " + game.score.toFixed(1) + "s"; centerPauseBtn.textContent = "继续" } else { pauseOverlay.classList.add("hidden"); centerPauseBtn.textContent = "暂停" } } } });
document.addEventListener("keyup", e => { if (e.key === "ArrowLeft" || e.key.toLowerCase() === "a") keys.left = false; if (e.key === "ArrowRight" || e.key.toLowerCase() === "d") keys.right = false });
let touchActive = false;
let pausedBeforeHelp = false;
function setPlayerX(x) { game.player.cx = Math.max(game.player.w / 2, Math.min(canvas.width - game.player.w / 2, x)) }
canvas.addEventListener("pointerdown", e => { if (e.pointerType !== "touch") return; const r = canvas.getBoundingClientRect(); setPlayerX(e.clientX - r.left); touchActive = true; e.preventDefault() });
canvas.addEventListener("pointermove", e => { if (e.pointerType !== "touch" || !touchActive) return; const r = canvas.getBoundingClientRect(); setPlayerX(e.clientX - r.left); e.preventDefault() });
canvas.addEventListener("pointerup", e => { if (e.pointerType !== "touch") return; touchActive = false });
canvas.addEventListener("pointercancel", e => { if (e.pointerType !== "touch") return; touchActive = false });
pauseBtn.addEventListener("click", () => { if (game.gameOver) return; game.paused = !game.paused; pauseBtn.textContent = game.paused ? "继续" : "暂停"; if (game.paused) { pauseOverlay.classList.remove("hidden"); pauseScore.textContent = "Score: " + game.score.toFixed(1) + "s"; centerPauseBtn.textContent = "继续" } else { pauseOverlay.classList.add("hidden"); centerPauseBtn.textContent = "暂停" } });
restartBtn.addEventListener("click", () => { game.reset(); pauseBtn.textContent = "暂停"; pauseOverlay.classList.add("hidden") });
centerPauseBtn.addEventListener("click", () => { if (game.gameOver) return; game.paused = !game.paused; pauseBtn.textContent = game.paused ? "继续" : "暂停"; if (game.paused) { pauseOverlay.classList.remove("hidden"); pauseScore.textContent = "Score: " + game.score.toFixed(1) + "s"; centerPauseBtn.textContent = "继续" } else { pauseOverlay.classList.add("hidden"); centerPauseBtn.textContent = "暂停" } });
helpBtn.addEventListener("click", () => { if (game.gameOver) return; pausedBeforeHelp = game.paused; game.paused = true; pauseBtn.textContent = "继续"; pauseOverlay.classList.add("hidden"); helpOverlay.classList.remove("hidden") });
helpCloseBtn.addEventListener("click", () => { helpOverlay.classList.add("hidden"); if (!pausedBeforeHelp && !game.gameOver) { game.paused = false; pauseBtn.textContent = "暂停" } else { game.paused = true; pauseBtn.textContent = "继续"; pauseOverlay.classList.remove("hidden") } });
if ("ontouchstart" in window) {
    canvas.addEventListener("touchstart", e => { const t = e.touches[0]; if (!t) return; const r = canvas.getBoundingClientRect(); setPlayerX(t.clientX - r.left); touchActive = true; e.preventDefault() }, { passive: false });
    canvas.addEventListener("touchmove", e => { const t = e.touches[0]; if (!t || !touchActive) return; const r = canvas.getBoundingClientRect(); setPlayerX(t.clientX - r.left); e.preventDefault() }, { passive: false });
    canvas.addEventListener("touchend", () => { touchActive = false }, { passive: true });
}
